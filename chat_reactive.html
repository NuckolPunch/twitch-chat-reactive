<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Twitch Chat Reactive PNG (Auto-Reconnect)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
    }
    #idle, #reacting {
      position: absolute;
      top: 0;
      left: 0;
      width: 300px; /* adjust as needed or add &width= in CSS if you prefer */
      image-rendering: auto;
    }
    #reacting { display: none; }
    #error {
      position: absolute;
      top: 8px;
      left: 8px;
      padding: 6px 10px;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
      background: rgba(220,0,0,0.4);
      border-radius: 6px;
      display: none; /* only shown if something goes wrong */
    }
  </style>
</head>
<body>
  <img id="idle" alt="Idle">
  <img id="reacting" alt="Reacting">
  <div id="error"></div>

  <script>
    // --- Params ---
    const params = new URLSearchParams(window.location.search);
    const channelName = params.get('channel');          // required
    const idleImgUrl  = params.get('idle');             // required
    const reactImgUrl = params.get('reacting');         // required
    const duration    = parseInt(params.get('duration') || '1500', 10); // ms

    // Validate
    if (!channelName || !idleImgUrl || !reactImgUrl) {
      document.body.innerHTML = `
        <div style="color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:20px;">
          <h2 style="margin:0 0 8px;">Missing required parameters.</h2>
          <p style="margin:0 0 8px;">Example:</p>
          <code>?channel=YourName&idle=https://example.com/idle.png&reacting=https://example.com/talk.png&duration=1500</code>
        </div>
      `;
      throw new Error('Missing ?channel, ?idle, or ?reacting');
    }

    // --- Elements (kept separate: no consolidated "avatar" variable) ---
    const idleEl = document.getElementById('idle');
    const reactEl = document.getElementById('reacting');
    const errorEl = document.getElementById('error');
    idleEl.src = idleImgUrl;
    reactEl.src = reactImgUrl;

    // --- Reaction logic (simple show/hide of the two images) ---
    let reactTimer = null;
    function showReactionOnce() {
      // Cancel any pending revert to ensure full visible duration on rapid chats
      if (reactTimer) clearTimeout(reactTimer);

      idleEl.style.display = 'none';
      reactEl.style.display = 'block';

      reactTimer = setTimeout(() => {
        idleEl.style.display = 'block';
        reactEl.style.display = 'none';
        reactTimer = null;
      }, duration);
    }

    // --- IRC via WebSocket (anonymous) with auto-reconnect ---
    const IRC_URL = 'wss://irc-ws.chat.twitch.tv:443';
    let ws = null;
    let reconnectAttempts = 0;
    let pingTimer = null;
    let lastPongAt = Date.now();

    function logError(msg) {
      console.error(msg);
      errorEl.textContent = String(msg);
      errorEl.style.display = 'block';
    }
    function clearError() {
      errorEl.style.display = 'none';
      errorEl.textContent = '';
    }

    function startPingWatchdog() {
      stopPingWatchdog();
      // Twitch sends PING periodically; we reply PONG. Also verify activity.
      pingTimer = setInterval(() => {
        // If we haven't heard anything in a long time, force reconnect
        const idleMs = Date.now() - lastPongAt;
        if (idleMs > 60_000) { // 60s of silence -> reconnect
          console.warn('No traffic for 60s; reconnecting...');
          reconnect('watchdog timeout');
          return;
        }
        // Proactively send a PING message upstream (not required, but helps keep NAT alive)
        try {
          ws && ws.readyState === WebSocket.OPEN && ws.send('PING :keepalive');
        } catch (e) {
          console.warn('Failed to send keepalive PING', e);
        }
      }, 20_000); // every 20s
    }

    function stopPingWatchdog() {
      if (pingTimer) {
        clearInterval(pingTimer);
        pingTimer = null;
      }
    }

    function connect() {
      clearError();
      ws = new WebSocket(IRC_URL);

      ws.addEventListener('open', () => {
        lastPongAt = Date.now();
        const nick = 'justinfan' + Math.floor(Math.random() * 1000000);
        ws.send('NICK ' + nick);
        ws.send('JOIN #' + channelName);
        reconnectAttempts = 0;
        startPingWatchdog();
      });

      ws.addEventListener('message', (event) => {
        const data = event.data;
        // Update last activity time
        lastPongAt = Date.now();

        // Handle PING/PONG (Twitch may send something like: "PING :tmi.twitch.tv")
        if (typeof data === 'string') {
          if (data.startsWith('PING')) {
            // Reply with PONG
            const payload = data.replace('PING', 'PONG');
            try { ws.send(payload); } catch {}
            return;
          }
          // Trigger on chat messages
          if (data.includes('PRIVMSG')) {
            showReactionOnce();
          }
        }
      });

      ws.addEventListener('error', (e) => {
        logError('WebSocket error – reconnecting…');
        reconnect('error');
      });

      ws.addEventListener('close', () => {
        logError('Connection closed – reconnecting…');
        reconnect('close');
      });
    }

    function reconnect(reason) {
      stopPingWatchdog();
      if (ws) {
        try { ws.close(); } catch {}
        ws = null;
      }
      const backoff = Math.min(1000 * Math.pow(2, reconnectAttempts), 15000); // 1s, 2s, 4s, ... cap 15s
      reconnectAttempts++;
      setTimeout(() => {
        connect();
      }, backoff);
    }

    // Reconnect if the page regains visibility (useful in OBS scene switches)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        // If not connected, try to connect
        if (!ws || ws.readyState === WebSocket.CLOSED) {
          reconnect('visible');
        }
      }
    });

    // Initial connect
    connect();

    // Optional: Refresh images on load errors to avoid "stuck" broken links
    idleEl.addEventListener('error', () => logError('Failed to load idle image.'));
    reactEl.addEventListener('error', () => logError('Failed to load reacting image.'));
  </script>
</body>
</html>
